<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>井字棋 - 人机对战</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- 配置Tailwind自定义颜色（黑色与牛皮色风格） -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: '#1A1A1A',
                        牛皮色: '#D2B48C',
                        牛皮色深: '#B8860B',
                        牛皮色浅: '#F5DEB3',
                    },
                    fontFamily: {
                        serif: ['Georgia', 'Cambria', 'serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .board-texture {
                background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%23000000' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
            }
            .cell-hover {
                transition: all 0.2s ease;
            }
            .cell-hover:hover {
                background-color: rgba(210, 180, 140, 0.7);
                transform: scale(1.05);
            }
            .piece-appear {
                animation: pieceAppear 0.3s ease-out forwards;
            }
            @keyframes pieceAppear {
                0% { transform: scale(0); opacity: 0; }
                70% { transform: scale(1.1); }
                100% { transform: scale(1); opacity: 1; }
            }
            .btn-press {
                transition: all 0.1s ease;
            }
            .btn-press:active {
                transform: scale(0.95);
            }
            .thinking {
                animation: thinking 1.5s infinite;
            }
            @keyframes thinking {
                0% { opacity: 0.7; }
                50% { opacity: 1; }
                100% { opacity: 0.7; }
            }
        }
    </style>
</head>
<body class="bg-牛皮色 board-texture min-h-screen font-serif text-dark">
    <div class="container mx-auto px-4 py-8 max-w-3xl">
        <!-- 游戏标题 -->
        <header class="text-center mb-8">
            <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-dark border-b-4 border-dark pb-2 inline-block">井字棋</h1>
            <p class="mt-4 text-lg text-dark/80">人机对战，轻松体验（有些不轻松）</p>
        </header>
        
        <!-- 游戏状态显示 -->
        <div class="text-center mb-6">
            <div id="status" class="text-xl font-semibold py-2 px-4 bg-dark text-牛皮色 inline-block rounded">
                游戏即将开始...
            </div>
        </div>
        
        <!-- 井字棋棋盘 -->
        <div class="flex justify-center mb-8">
            <div id="board" class="grid grid-cols-3 gap-4 p-6 bg-dark rounded-lg shadow-xl">
                <!-- 棋盘格子将通过JS动态生成 -->
            </div>
        </div>
        
        <!-- 控制按钮（仅保留重新开始） -->
        <div class="flex justify-center">
            <button id="resetBtn" class="bg-dark text-牛皮色 hover:bg-dark/80 py-3 px-6 rounded-lg font-medium transition-all duration-300 btn-press flex items-center">
                <i class="fa fa-refresh mr-2"></i>重新开始
            </button>
        </div>
        
        <!-- 游戏说明 -->
        <div class="mt-12 text-center text-dark/80 max-w-md mx-auto">
            <h2 class="text-xl font-bold mb-2">游戏规则</h2>
            <p>玩家控制 X，电脑控制 O，轮流落子。随机决定谁先出手，先将三个相同棋子连成一条线（横、竖、斜）的一方获胜。</p>
        </div>
    </div>

    <script>
        // 游戏状态变量
        let currentPlayer = 'X'; // 玩家是X，电脑是O
        let gameBoard = ['', '', '', '', '', '', '', '', ''];
        let gameActive = true;
        let isPlayerTurn = true; // 标记是否是玩家回合
        
        // 获胜组合
        const winningCombinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // 横向
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // 纵向
            [0, 4, 8], [2, 4, 6]             // 对角线
        ];
        
        // 难度调整参数 - 控制电脑AI的犯错概率
        const difficulty = {
            winProbability: 0.95,    // 电脑有80%概率选择能直接获胜的位置
            defendProbability: 0.9, // 电脑有60%概率选择防守位置
            randomMoveProbability: 0.1 // 随机落子的概率
        };
        
        // DOM 元素
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetBtn');
        
        // 初始化棋盘
        function initializeBoard() {
            boardElement.innerHTML = '';
            gameBoard = ['', '', '', '', '', '', '', '', ''];
            gameActive = true;
            
            // 随机决定谁先出手（增加玩家先手概率到60%，降低难度）
            isPlayerTurn = Math.random() > 0.5;
            currentPlayer = isPlayerTurn ? 'X' : 'O';
            
            // 创建棋盘格子
            gameBoard.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add(
                    'cell', 
                    'w-24', 
                    'h-24', 
                    'bg-牛皮色', 
                    'rounded-md', 
                    'flex', 
                    'items-center', 
                    'justify-center', 
                    'text-5xl', 
                    'font-bold', 
                    'cursor-pointer',
                    'cell-hover',
                    'shadow-md'
                );
                cellElement.dataset.index = index;
                cellElement.addEventListener('click', handleCellClick);
                boardElement.appendChild(cellElement);
            });
            
            updateStatus();
            
            // 如果是电脑先出手，延迟一点时间再落子
            if (!isPlayerTurn) {
                setTimeout(computerMove, 800);
            }
        }
        
        // 处理玩家点击格子
        function handleCellClick(event) {
            // 只有玩家回合且游戏活跃时才能点击
            if (!isPlayerTurn || !gameActive) {
                return;
            }
            
            const index = parseInt(event.target.dataset.index);
            
            // 检查格子是否已被占用
            if (gameBoard[index] !== '') {
                return;
            }
            
            // 玩家落子（X）
            gameBoard[index] = 'X';
            renderBoard();
            
            // 检查游戏结果
            if (checkWinner()) {
                statusElement.textContent = '恭喜！你战胜了电脑！';
                gameActive = false;
                return;
            }
            
            // 检查平局
            if (checkTie()) {
                statusElement.textContent = '- 平局 -';
                gameActive = false;
                return;
            }
            
            // 切换到电脑回合
            isPlayerTurn = false;
            currentPlayer = 'O';
            updateStatus();
            
            // 电脑思考一会儿再落子
            setTimeout(computerMove, 800);
        }
        
        // 电脑落子（O）
        function computerMove() {
            if (!gameActive || isPlayerTurn) {
                return;
            }
            
            // 智能选择落子位置（带随机性）
            const bestMove = getBestMove();
            
            // 电脑落子
            gameBoard[bestMove] = 'O';
            renderBoard();
            
            // 检查游戏结果
            if (checkWinner()) {
                statusElement.textContent = '电脑获胜！，……';
                gameActive = false;
                return;
            }
            
            // 检查平局
            if (checkTie()) {
                statusElement.textContent = '- 平局 -';
                gameActive = false;
                return;
            }
            
            // 切换到玩家回合
            isPlayerTurn = true;
            currentPlayer = 'X';
            updateStatus();
        }
        
        // 获取所有可用位置
        function getAvailableMoves() {
            return gameBoard.map((cell, index) => cell === '' ? index : null).filter(index => index !== null);
        }
        
        // 随机选择一个可用位置
        function getRandomMove() {
            const availableMoves = getAvailableMoves();
            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }
        
        // 调整后的AI：计算最佳落子位置（带随机性，降低难度）
        function getBestMove() {
            // 有一定概率随机落子，增加电脑犯错可能
            if (Math.random() < difficulty.randomMoveProbability) {
                return getRandomMove();
            }
            
            // 1. 检查是否能一步获胜（有概率错过）
            const winningMoves = [];
            for (let i = 0; i < gameBoard.length; i++) {
                if (gameBoard[i] === '') {
                    gameBoard[i] = 'O';
                    if (checkWinner()) {
                        winningMoves.push(i);
                    }
                    gameBoard[i] = ''; // 回溯
                }
            }
            // 如果有获胜机会，按概率选择
            if (winningMoves.length > 0 && Math.random() < difficulty.winProbability) {
                return winningMoves[Math.floor(Math.random() * winningMoves.length)];
            }
            
            // 2. 检查是否需要防守（有概率错过）
            const defensiveMoves = [];
            for (let i = 0; i < gameBoard.length; i++) {
                if (gameBoard[i] === '') {
                    gameBoard[i] = 'X';
                    if (checkWinner()) {
                        defensiveMoves.push(i);
                    }
                    gameBoard[i] = ''; // 回溯
                }
            }
            // 如果有需要防守的位置，按概率选择
            if (defensiveMoves.length > 0 && Math.random() < difficulty.defendProbability) {
                return defensiveMoves[Math.floor(Math.random() * defensiveMoves.length)];
            }
            
            // 3. 尝试占领中心（有概率随机选择其他位置）
            if (gameBoard[4] === '' && Math.random() > 0.3) {
                return 4;
            }
            
            // 4. 尝试占领角落或边缘（增加随机性）
            const corners = [0, 2, 6, 8].filter(index => gameBoard[index] === '');
            const edges = [1, 3, 5, 7].filter(index => gameBoard[index] === '');
            
            // 混合选择角落和边缘，增加随机性
            const preferredMoves = [...corners, ...edges];
            if (preferredMoves.length > 0) {
                return preferredMoves[Math.floor(Math.random() * preferredMoves.length)];
            }
            
            // 兜底：返回随机位置
            return getRandomMove();
        }
        
        // 渲染棋盘
        function renderBoard() {
            const cells = document.getElementsByClassName('cell');
            gameBoard.forEach((cell, index) => {
                cells[index].textContent = cell;
                if (cell) {
                    cells[index].classList.add('piece-appear');
                    // X使用黑色（玩家），O使用深牛皮色（电脑）
                    cells[index].style.color = cell === 'X' ? '#000' : '#B8860B';
                }
            });
        }
        
        // 更新状态显示
        function updateStatus() {
            if (!gameActive) return;
            
            if (isPlayerTurn) {
                statusElement.textContent = '轮到你落子（X）';
                statusElement.classList.remove('thinking');
            } else {
                statusElement.textContent = '电脑思考中...';
                statusElement.classList.add('thinking');
            }
        }
        
        // 检查获胜者
        function checkWinner() {
            return winningCombinations.some(combination => {
                const [a, b, c] = combination;
                return gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c];
            });
        }
        
        // 检查平局
        function checkTie() {
            return gameBoard.every(cell => cell !== '');
        }
        
        // 重置游戏
        function resetGame() {
            initializeBoard();
        }
        
        // 事件监听
        resetButton.addEventListener('click', resetGame);
        
        // 初始化游戏
        initializeBoard();
    </script>
</body>
</html>